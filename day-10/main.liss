(import "strings" ["split" "atoi"])
(import "list" ["map" "reduce"])
(import "math" ["min"])

(let IS_DEBUG? false)

(fn read_input_file [src]
    (let f (fopen src))
    (let data (fread_all f))
    (fclose f)
    data
)

(fn parse_light [S]
    (list:map (strings:trim S "[]") (fn [ch]
        (switch ch
            ["." false]
            ["#" true]
            [* (raise! (+ "unexpected light: " ch))]
        )
    ))
)

(fn parse_button [S]
    (list:map (strings:split (strings:trim S "()") ",") strings:atoi)
)

(fn parse_req [S]
    (list:map (strings:split (strings:trim S "{}") ",") strings:atoi)
)

(let LIGHTS   0)
(let BUTTONS  1)
(let SENSORS  2)

(fn parse_reading [line]
    (list:reduce (strings:split line " ") (fn [acc S]
        (switch (get S 0)
            ["[" (
                (let light (parse_light S))
                (put acc LIGHTS light)
            )]
            ["(" (
                (let button (parse_button S))
                (put acc BUTTONS (list:push (get acc BUTTONS) button))
            )]
            ["{" (
                (let req (parse_req S))
                (put acc SENSORS req)
            )]
            [* (raise! (+ "unexpected reading: " S))]
        )
        acc
    ) [null [] null]) 
)

(fn eql [A B]
    (fn _next [ix]
        (cond (>= ix (len A))
            true
            (cond (not (= (get A ix) (get B ix)))
                false
                (_next (+ ix 1))
            )
        )
    )
    (cond (not (= (len A) (len B)))
        false
        (_next 0)
    )
)

(fn apply [vec msk]
    (let cpvec (list:copy vec))
    (list:map msk (fn [ix]
        (put cpvec ix (not (get cpvec ix)))
    ))
    cpvec
)

(let INF 9999)

(fn count_min_press [R]
    (let L (get R LIGHTS))
    (let BS (get R BUTTONS))
    (let lenBS (len BS))

    (let W (* [false] (len (get R LIGHTS))))
    (cond IS_DEBUG? (println "W=" W))


    (fn _recurse [cnt ST bix]
        (cond (eql ST L)
            cnt
            (cond (>= bix lenBS)
                INF
                (math:min
                    (_recurse (+ cnt 1) (apply ST (get BS bix)) (+ bix 1))
                    (_recurse cnt ST (+ bix 1))
                )
            )
        )
    )

    (_recurse 0 W 0)
)

(fn sums_up? [BS PS SRS]
    (fn _next [bix cur]
        (cond (>= bix (len BS))
            (
                (cond IS_DEBUG? (println cur " == " SRS))
                (eql cur SRS)
            )
            (
                (let bump (list:reduce (get BS bix) (fn [acc six]
                    (put cur six (+ (get cur six) (get PS bix)))
                    (and acc (<= (get cur six) (get SRS six)))
                ) true))
                (cond bump
                    (_next (+ bix 1) cur)
                )
            )
        )
    )
    (_next 0 (* [0] (len SRS)))
)

(fn count_min_press2 [R]
    (let BS (get R BUTTONS))
    (let SRS (get R SENSORS))
    (let maxPS (list:reduce
        (list:seq 0 (len BS))
        (fn [acc bix]
            (put acc bix (list:reduce (get BS bix) (fn [acc six]
                (math:min acc (get SRS six))
            ) (get acc bix)))
            acc
        )
        (* [INF] (len BS))
    ))
    (cond IS_DEBUG? (println "maxPS=" maxPS))

    ; Idea:
    ; first, build an index:
    ;   S2B
    ;   six1 -> [bix1 bix2 bix3]
    ;   six2 -> [bix2 bix4]
    ; 
    ; for each bix in [bix1 bix2 bix3]
    ;   start with : bix -> (fn [] (INF))
    ;   continue with each six:
    ;     new_fn (fn [] subtract (get maxPS bix) with the current values of all PS under bix'es
    ;     except this one)
    ; for each sensor:
    ;    bix -> (math:min (pref_fn) (new_fn))
    ; if maxPS for this bix is negative, return early

    (fn _next [minP bix PS psSum]
        (cond (>= psSum minP)
            minP
            (cond (>= bix (len BS))
                minP
                (cond (> (get PS bix) (get maxPS bix))
                    minP
                    (
                        (cond IS_DEBUG? (println PS))
                        (let minP0 (cond (sums_up? BS PS SRS)
                            (math:min minP (list:sum PS))
                            minP
                        ))
                        (let minP1 (_next minP0 (+ bix 1) PS psSum))
                        (let curP (get PS bix))
                        (put PS bix (+ curP 1))
                        (let minP2 (_next (math:min minP0 minP1) bix PS (+ psSum 1)))
                        (cond IS_DEBUG? (println "minP=" minP2))
                        (put PS bix curP)
                        minP2
                    )
                )
            )
        )
    )

    (let PS (* [0] (len BS)))

    (_next (list:sum SRS) 0 PS 0)
)

((fn main []
    ;(let input (read_input_file "INPUT-TST"))
    (let input (read_input_file "INPUT"))
    (let lines (strings:split input "\n"))

    (let RS (list:map lines parse_reading))
    (cond IS_DEBUG? (println "RS=" RS))

    (let res1 (list:reduce RS (fn [acc R]
        (let np (count_min_press R))
        (cond IS_DEBUG? (println "min press for " (get R LIGHTS) " is " np))
        (+acc np)
    ) 0))
    (println "res1=" res1)

    (let res2 (list:reduce RS (fn [acc R]
        (println "processing " R)
        (let np (count_min_press2 R))
        (println "min press 2 for " (get R SENSORS) " is " np)
        (+ acc np)
    ) 0))
    (println "res2=" res2)
))
