; This one is taken from https://www.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/

(import "strings" ["split" "atoi"])
(import "list" ["map" "reduce"])
(import "math" ["min"])
(import "test_utils" ["benchmark"] as tu)

(let IS_DEBUG? false)

(fn read_input_file [src]
    (let f (fopen src))
    (let data (fread_all f))
    (fclose f)
    data
)

(fn parse_light [S]
    (list:map (strings:trim S "[]") (fn [ch]
        (switch ch
            ["." 0]
            ["#" 1]
            [* (raise! (+ "unexpected light: " ch))]
        )
    ))
)

(fn parse_button [S]
    (list:map (strings:split (strings:trim S "()") ",") strings:atoi)
)

(fn parse_req [S]
    (list:map (strings:split (strings:trim S "{}") ",") strings:atoi)
)

(let LIGHTS   0)
(let BUTTONS  1)
(let SENSORS  2)

(fn parse_reading [line]
    (list:reduce (strings:split line " ") (fn [acc S]
        (switch (get S 0)
            ["[" (
                (let light (parse_light S))
                (put acc LIGHTS light)
            )]
            ["(" (
                (let button (parse_button S))
                (put acc BUTTONS (list:push (get acc BUTTONS) button))
            )]
            ["{" (
                (let req (parse_req S))
                (put acc SENSORS req)
            )]
            [* (raise! (+ "unexpected reading: " S))]
        )
        acc
    ) [null [] null]) 
)

(fn eql [A B]
    (fn _next [ix]
        (cond (>= ix (len A))
            true
            (cond (not (= (get A ix) (get B ix)))
                false
                (_next (+ ix 1))
            )
        )
    )
    (cond (not (= (len A) (len B)))
        false
        (_next 0)
    )
)

(fn apply [vec msk]
    (let cpvec (list:copy vec))
    (list:map msk (fn [ix]
        (put cpvec ix (% (+ (get cpvec ix) 1) 2))
    ))
    cpvec
)

(let INF 9999999)

(fn find_all_presses [BS PAT]
    (fn _next [presses bix state]
        (let ps0 (cond (eql PAT state)
            [(list:copy presses)]
            []
        ))
        (cond (>= bix (len BS))
            ps0
            (
                (let st1 (apply state (get BS bix)))
                (let ps1 (_next (+ presses [bix]) (+ bix 1) st1))
                (let ps2 (_next presses (+ bix 1) state))
                (+ ps0 ps1 ps2)
            )
        )
    )
    (_next [] 0 (* [0] (len PAT)))
)

(fn count_min_press [R]
    (let all_presses (find_all_presses (get R BUTTONS) (get R LIGHTS)))
    (list:reduce all_presses (fn [acc press]
        (math:min acc (len press))
    ) INF)
)

(fn subtract_all [BS state bixs]
    (fn _next [acc bix six]
        (cond (>= bix (len bixs))
            acc
            (
                (let but (get BS (get bixs bix)))
                (cond (>= six (len but))
                    (_next acc (+ bix 1) 0)
                    (
                        (let deduct (- (get acc (get but six)) 1))
                        (cond (< deduct 0)
                            null
                            (
                                (put acc (get but six) deduct)
                                (_next acc bix (+ six 1))
                            )
                        )
                    )
                )
            )
        )
    )
    (_next (list:copy state) 0 0)
)

(fn count_min_press2 [R]
    (let BS (get R BUTTONS))
    (let SNS (get R SENSORS))
    (let zeroes (* [0] (len SNS)))
    (let cache (dict))
    (let state_cache (dict))
    (fn _next [state]
        (let state_key (str state))
        (cond (has? state_cache state_key)
            (get state_cache state_key)
            (
                (let R (cond (eql state zeroes)
                    0 ; no more buttons to press, yay!
                    (
                        (let next_pat (list:map (list:seq 0 (len SNS)) (fn [ix]
                            (% (get state ix) 2)
                        )))
                        (let cache_key (str next_pat))
                        (let all_presses (cond (has? cache cache_key)
                            (get cache cache_key)
                            (
                                (let pps (find_all_presses BS next_pat))
                                (put cache cache_key pps)
                                pps
                            )
                        ))
                        (list:reduce all_presses (fn [acc press]
                            (let next_state (subtract_all BS state press))
                            (cond (is_null? next_state)
                                acc
                                (
                                    (let half_state (list:map next_state (fn [el] (/ el 2))))
                                    (let mp (_next half_state))
                                    (cond (= mp INF)
                                        acc
                                        (math:min acc (+ (* mp 2) (len press)))
                                    )
                                )
                            )
                        ) INF) ; INF would be returned in case when no combination of presses would give us the desired result
                    )
                ))
                (put state_cache state_key R)
                R
            )
        )
    )
    (_next (get R SENSORS))
)

(tu:benchmark "day 10" (fn main []
    ;(let input (read_input_file "INPUT-TST"))
    (let input (read_input_file "INPUT"))
    (let lines (strings:split input "\n"))

    (let RS (list:map lines parse_reading))
    (cond IS_DEBUG? (println "RS=" RS))

    (let res1 (list:reduce RS (fn [acc R]
        (let np (count_min_press R))
        (cond IS_DEBUG? (println "min press for " (get R LIGHTS) " is " np))
        (+acc np)
    ) 0))
    (println "res1=" res1)

    (let res2 (list:reduce RS (fn [acc R]
        (cond IS_DEBUG? (println "processing " R))
        (let np (count_min_press2 R))
        (cond IS_DEBUG? (println "min press 2 for " (get R SENSORS) " is " np))
        (+ acc np)
    ) 0))
    (println "res2=" res2)
))
